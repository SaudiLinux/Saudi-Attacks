#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
وحدة فحص الثغرات الأمنية
"""

import json
import requests
import re
import socket
import ssl
from colorama import Fore, Style
from datetime import datetime
from .utils import print_status, is_valid_ip, is_valid_domain, resolve_host, run_command

class VulnerabilityScanner:
    """
    فئة فحص الثغرات الأمنية
    """
    def __init__(self, target, logger, quiet=False, debug=False):
        """
        تهيئة الفئة
        """
        self.target = target
        self.logger = logger
        self.quiet = quiet
        self.debug = debug
        self.results = {}
        
        # تحديد نوع الهدف (IP أو اسم مجال)
        if is_valid_ip(target):
            self.target_type = "ip"
            self.ip = target
        elif is_valid_domain(target):
            self.target_type = "domain"
            self.ip = resolve_host(target)
        else:
            self.target_type = "unknown"
            self.ip = None
        
        # قائمة الثغرات المعروفة
        self.known_vulnerabilities = self._load_known_vulnerabilities()
    
    def _load_known_vulnerabilities(self):
        """
        تحميل قائمة الثغرات المعروفة
        """
        # هذه مجرد قائمة بسيطة للتوضيح، في التطبيق الحقيقي يمكن تحميلها من ملف أو قاعدة بيانات
        return {
            "heartbleed": {
                "name": "Heartbleed (CVE-2014-0160)",
                "description": "ثغرة في مكتبة OpenSSL تسمح بتسريب الذاكرة",
                "severity": "عالية",
                "ports": [443, 8443],
                "check": self._check_heartbleed
            },
            "shellshock": {
                "name": "Shellshock (CVE-2014-6271)",
                "description": "ثغرة في Bash تسمح بتنفيذ أوامر عن بعد",
                "severity": "عالية",
                "ports": [80, 443],
                "check": self._check_shellshock
            },
            "poodle": {
                "name": "POODLE (CVE-2014-3566)",
                "description": "ثغرة في بروتوكول SSLv3 تسمح بكشف المعلومات المشفرة",
                "severity": "متوسطة",
                "ports": [443, 8443],
                "check": self._check_poodle
            },
            "freak": {
                "name": "FREAK (CVE-2015-0204)",
                "description": "ثغرة في SSL/TLS تسمح بخفض قوة التشفير",
                "severity": "متوسطة",
                "ports": [443, 8443],
                "check": self._check_freak
            },
            "logjam": {
                "name": "Logjam (CVE-2015-4000)",
                "description": "ثغرة في تبادل مفاتيح Diffie-Hellman تسمح بهجمات MITM",
                "severity": "متوسطة",
                "ports": [443, 8443],
                "check": self._check_logjam
            },
            "drown": {
                "name": "DROWN (CVE-2016-0800)",
                "description": "ثغرة في SSLv2 تسمح بفك تشفير اتصالات TLS",
                "severity": "عالية",
                "ports": [443, 8443],
                "check": self._check_drown
            },
            "sweet32": {
                "name": "Sweet32 (CVE-2016-2183)",
                "description": "ثغرة في خوارزميات التشفير ذات الكتل 64 بت",
                "severity": "منخفضة",
                "ports": [443, 8443],
                "check": self._check_sweet32
            },
            "ticketbleed": {
                "name": "Ticketbleed (CVE-2016-9244)",
                "description": "ثغرة في F5 BIG-IP تسمح بتسريب الذاكرة",
                "severity": "متوسطة",
                "ports": [443, 8443],
                "check": self._check_ticketbleed
            },
            "robot": {
                "name": "ROBOT (CVE-2017-13099)",
                "description": "ثغرة في تنفيذ RSA تسمح بفك التشفير",
                "severity": "عالية",
                "ports": [443, 8443],
                "check": self._check_robot
            },
            "beast": {
                "name": "BEAST (CVE-2011-3389)",
                "description": "ثغرة في TLS 1.0 تسمح بهجمات MITM",
                "severity": "متوسطة",
                "ports": [443, 8443],
                "check": self._check_beast
            }
        }
    
    def scan(self):
        """
        فحص الثغرات الأمنية
        """
        if not self.ip:
            if not self.quiet:
                print_status(f"لا يمكن تحليل الهدف: {self.target}", "error")
            self.logger.error(f"لا يمكن تحليل الهدف: {self.target}")
            return {"error": f"لا يمكن تحليل الهدف: {self.target}"}
        
        if not self.quiet:
            print_status(f"بدء فحص الثغرات الأمنية للهدف: {self.target} ({self.ip})", "info")
        
        self.logger.info(f"بدء فحص الثغرات الأمنية للهدف: {self.target} ({self.ip})")
        
        # فحص الثغرات المعروفة
        self._scan_known_vulnerabilities()
        
        # فحص إعدادات SSL/TLS
        self._scan_ssl_tls()
        
        # فحص الخدمات المعرضة للخطر
        self._scan_exposed_services()
        
        # فحص الإعدادات الخاطئة
        self._scan_misconfigurations()
        
        if not self.quiet:
            print_status(f"اكتمال فحص الثغرات الأمنية للهدف: {self.target}", "success")
        
        self.logger.info(f"اكتمال فحص الثغرات الأمنية للهدف: {self.target}")
        
        return self.results
    
    def _scan_known_vulnerabilities(self):
        """
        فحص الثغرات المعروفة
        """
        if not self.quiet:
            print_status("فحص الثغرات المعروفة...", "info")
        
        vulnerabilities = []
        
        for vuln_id, vuln_info in self.known_vulnerabilities.items():
            try:
                if not self.quiet:
                    print_status(f"فحص {vuln_info['name']}...", "info")
                
                # فحص الثغرة
                result = vuln_info["check"]()
                
                if result["vulnerable"]:
                    vulnerabilities.append({
                        "id": vuln_id,
                        "name": vuln_info["name"],
                        "description": vuln_info["description"],
                        "severity": vuln_info["severity"],
                        "details": result.get("details", "")
                    })
                    
                    if not self.quiet:
                        print_status(f"الهدف معرض لثغرة {vuln_info['name']}", "warning")
                        if "details" in result:
                            print_status(f"التفاصيل: {result['details']}", "info")
            except Exception as e:
                if self.debug:
                    print_status(f"فشل في فحص {vuln_info['name']}: {str(e)}", "error")
        
        self.results["known_vulnerabilities"] = vulnerabilities
    
    def _scan_ssl_tls(self):
        """
        فحص إعدادات SSL/TLS
        """
        if not self.quiet:
            print_status("فحص إعدادات SSL/TLS...", "info")
        
        ssl_issues = []
        
        # فحص بروتوكولات SSL/TLS المدعومة
        protocols = {
            ssl.PROTOCOL_SSLv23: "SSL/TLS",
            ssl.PROTOCOL_TLSv1: "TLSv1",
            ssl.PROTOCOL_TLSv1_1: "TLSv1.1",
            ssl.PROTOCOL_TLSv1_2: "TLSv1.2"
        }
        
        for port in [443, 8443]:
            for protocol, protocol_name in protocols.items():
                try:
                    context = ssl.SSLContext(protocol)
                    with socket.create_connection((self.ip, port), timeout=5) as sock:
                        with context.wrap_socket(sock, server_hostname=self.target if self.target_type == "domain" else None) as ssock:
                            cipher = ssock.cipher()
                            if protocol in [ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1]:
                                ssl_issues.append({
                                    "type": "protocol",
                                    "name": f"بروتوكول {protocol_name} قديم",
                                    "description": f"الخادم يدعم بروتوكول {protocol_name} القديم والضعيف",
                                    "severity": "متوسطة",
                                    "port": port,
                                    "details": f"الشفرة المستخدمة: {cipher[0]}"
                                })
                                
                                if not self.quiet:
                                    print_status(f"الخادم يدعم بروتوكول {protocol_name} القديم على المنفذ {port}", "warning")
                except (socket.timeout, socket.error, ssl.SSLError):
                    pass
        
        self.results["ssl_tls_issues"] = ssl_issues
    
    def _scan_exposed_services(self):
        """
        فحص الخدمات المعرضة للخطر
        """
        if not self.quiet:
            print_status("فحص الخدمات المعرضة للخطر...", "info")
        
        exposed_services = []
        
        # قائمة الخدمات والمنافذ التي يجب فحصها
        services_to_check = {
            21: "FTP",
            22: "SSH",
            23: "Telnet",
            25: "SMTP",
            53: "DNS",
            110: "POP3",
            111: "RPC",
            135: "RPC",
            139: "NetBIOS",
            445: "SMB",
            1433: "MSSQL",
            1521: "Oracle",
            3306: "MySQL",
            3389: "RDP",
            5432: "PostgreSQL",
            5900: "VNC",
            6379: "Redis",
            8080: "HTTP Proxy",
            9200: "Elasticsearch",
            27017: "MongoDB"
        }
        
        for port, service_name in services_to_check.items():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.ip, port))
                sock.close()
                
                if result == 0:
                    exposed_services.append({
                        "port": port,
                        "service": service_name,
                        "description": f"خدمة {service_name} مفتوحة على المنفذ {port}",
                        "severity": "منخفضة" if port in [22, 443] else "متوسطة"
                    })
                    
                    if not self.quiet:
                        print_status(f"خدمة {service_name} مفتوحة على المنفذ {port}", "warning")
            except Exception as e:
                if self.debug:
                    print_status(f"فشل في فحص المنفذ {port}: {str(e)}", "error")
        
        self.results["exposed_services"] = exposed_services
    
    def _scan_misconfigurations(self):
        """
        فحص الإعدادات الخاطئة
        """
        if not self.quiet:
            print_status("فحص الإعدادات الخاطئة...", "info")
        
        misconfigurations = []
        
        # فحص الملفات الحساسة المكشوفة
        sensitive_files = [
            "/robots.txt",
            "/sitemap.xml",
            "/.git/",
            "/.env",
            "/backup/",
            "/phpinfo.php",
            "/server-status",
            "/wp-config.php",
            "/config.php",
            "/admin/",
            "/administrator/",
            "/wp-admin/",
            "/wp-login.php"
        ]
        
        for file_path in sensitive_files:
            try:
                url = f"http://{self.target}{file_path}"
                response = requests.get(url, timeout=5, allow_redirects=False)
                
                if response.status_code == 200:
                    misconfigurations.append({
                        "type": "exposed_file",
                        "name": f"ملف حساس مكشوف: {file_path}",
                        "description": f"الملف الحساس {file_path} متاح للوصول العام",
                        "severity": "متوسطة",
                        "url": url
                    })
                    
                    if not self.quiet:
                        print_status(f"ملف حساس مكشوف: {url}", "warning")
            except requests.RequestException:
                pass
        
        # فحص رؤوس HTTP الأمنية المفقودة
        try:
            url = f"https://{self.target}" if self.target_type == "domain" else f"https://{self.ip}"
            response = requests.get(url, timeout=5, verify=False)
            
            security_headers = {
                "Strict-Transport-Security": "HSTS",
                "Content-Security-Policy": "CSP",
                "X-Content-Type-Options": "X-Content-Type-Options",
                "X-Frame-Options": "X-Frame-Options",
                "X-XSS-Protection": "X-XSS-Protection"
            }
            
            for header, header_name in security_headers.items():
                if header not in response.headers:
                    misconfigurations.append({
                        "type": "missing_header",
                        "name": f"رأس HTTP الأمني مفقود: {header}",
                        "description": f"رأس HTTP الأمني {header} ({header_name}) مفقود",
                        "severity": "منخفضة",
                        "url": url
                    })
                    
                    if not self.quiet:
                        print_status(f"رأس HTTP الأمني مفقود: {header}", "warning")
        except requests.RequestException:
            pass
        
        self.results["misconfigurations"] = misconfigurations
    
    # دوال فحص الثغرات المعروفة
    
    def _check_heartbleed(self):
        """
        فحص ثغرة Heartbleed
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        for port in [443, 8443]:
            try:
                # محاولة الاتصال بالمنفذ
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((self.ip, port))
                sock.close()
                
                if result == 0:
                    # التحقق من إصدار OpenSSL
                    context = ssl.create_default_context()
                    context.check_hostname = False
                    context.verify_mode = ssl.CERT_NONE
                    
                    with socket.create_connection((self.ip, port), timeout=5) as sock:
                        with context.wrap_socket(sock, server_hostname=self.target if self.target_type == "domain" else None) as ssock:
                            version = ssock.version()
                            if "TLSv1" in version and not "TLSv1.2" in version:
                                return {"vulnerable": True, "details": f"المنفذ {port} يستخدم إصدار SSL/TLS قديم: {version}"}
            except Exception:
                pass
        
        return {"vulnerable": False}
    
    def _check_shellshock(self):
        """
        فحص ثغرة Shellshock
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        for port in [80, 443]:
            try:
                protocol = "https" if port == 443 else "http"
                url = f"{protocol}://{self.target}/cgi-bin/test.cgi"
                headers = {"User-Agent": "() { :; }; echo; echo vulnerable"}
                
                response = requests.get(url, headers=headers, timeout=5, verify=False)
                
                if "vulnerable" in response.text:
                    return {"vulnerable": True, "details": f"المنفذ {port} معرض لثغرة Shellshock"}
            except requests.RequestException:
                pass
        
        return {"vulnerable": False}
    
    def _check_poodle(self):
        """
        فحص ثغرة POODLE
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        for port in [443, 8443]:
            try:
                # محاولة الاتصال باستخدام SSLv3
                context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
                context.options &= ~ssl.OP_NO_SSLv3
                
                with socket.create_connection((self.ip, port), timeout=5) as sock:
                    with context.wrap_socket(sock, server_hostname=self.target if self.target_type == "domain" else None) as ssock:
                        version = ssock.version()
                        if "SSLv3" in version:
                            return {"vulnerable": True, "details": f"المنفذ {port} يدعم بروتوكول SSLv3 الضعيف"}
            except Exception:
                pass
        
        return {"vulnerable": False}
    
    def _check_freak(self):
        """
        فحص ثغرة FREAK
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        return {"vulnerable": False}
    
    def _check_logjam(self):
        """
        فحص ثغرة Logjam
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        return {"vulnerable": False}
    
    def _check_drown(self):
        """
        فحص ثغرة DROWN
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        return {"vulnerable": False}
    
    def _check_sweet32(self):
        """
        فحص ثغرة Sweet32
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        return {"vulnerable": False}
    
    def _check_ticketbleed(self):
        """
        فحص ثغرة Ticketbleed
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        return {"vulnerable": False}
    
    def _check_robot(self):
        """
        فحص ثغرة ROBOT
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        return {"vulnerable": False}
    
    def _check_beast(self):
        """
        فحص ثغرة BEAST
        """
        # هذا مجرد تنفيذ بسيط للتوضيح، في التطبيق الحقيقي يجب استخدام أدوات أكثر تقدمًا
        for port in [443, 8443]:
            try:
                # محاولة الاتصال باستخدام TLSv1
                context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
                
                with socket.create_connection((self.ip, port), timeout=5) as sock:
                    with context.wrap_socket(sock, server_hostname=self.target if self.target_type == "domain" else None) as ssock:
                        version = ssock.version()
                        cipher = ssock.cipher()
                        if "TLSv1" in version and not "TLSv1.1" in version and not "TLSv1.2" in version:
                            return {"vulnerable": True, "details": f"المنفذ {port} يستخدم بروتوكول TLSv1 الضعيف مع الشفرة {cipher[0]}"}
            except Exception:
                pass
        
        return {"vulnerable": False}

if __name__ == "__main__":
    # اختبار الوحدة
    import logging
    logger = logging.getLogger("test")
    
    target = "example.com"
    scanner = VulnerabilityScanner(target, logger, quiet=False, debug=True)
    results = scanner.scan()
    
    print(json.dumps(results, indent=4, default=str))