#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
اختبارات وحدة فحص الثغرات الأمنية
"""

import unittest
import sys
import os
import logging
from unittest.mock import patch, MagicMock

# إضافة المجلد الرئيسي إلى مسار البحث
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from modules.vulnerability_scanner import VulnerabilityScanner

class TestVulnerabilityScanner(unittest.TestCase):
    """
    اختبارات لوحدة فحص الثغرات الأمنية
    """
    
    def setUp(self):
        """
        إعداد بيئة الاختبار
        """
        # إنشاء مسجل اختبار
        self.logger = logging.getLogger('test_logger')
        self.logger.setLevel(logging.DEBUG)
        # إنشاء معالج للطباعة على وحدة التحكم
        handler = logging.StreamHandler()
        handler.setLevel(logging.DEBUG)
        # إضافة المعالج إلى المسجل
        self.logger.addHandler(handler)
        
        # إنشاء كائن VulnerabilityScanner للاختبار
        self.vuln_scanner = VulnerabilityScanner('example.com', self.logger, quiet=True, debug=True)
    
    def test_initialization(self):
        """
        اختبار تهيئة الكائن
        """
        self.assertEqual(self.vuln_scanner.target, 'example.com')
        self.assertTrue(self.vuln_scanner.quiet)
        self.assertTrue(self.vuln_scanner.debug)
        self.assertIsNotNone(self.vuln_scanner.known_vulnerabilities)
        self.assertGreater(len(self.vuln_scanner.known_vulnerabilities), 0)
    
    @patch('modules.vulnerability_scanner.requests.get')
    def test_check_heartbleed(self, mock_get):
        """
        اختبار فحص ثغرة Heartbleed
        """
        # إعداد الاستجابة الوهمية
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.text = 'OpenSSL 1.0.1e'
        mock_get.return_value = mock_response
        
        # تنفيذ فحص ثغرة Heartbleed
        result = self.vuln_scanner._check_heartbleed()
        
        # التحقق من النتائج
        self.assertIsNotNone(result)
        self.assertTrue(result['vulnerable'])
        self.assertIn('OpenSSL 1.0.1', result['details'])
        
        # التحقق من استدعاء الدالة الوهمية
        mock_get.assert_called_once()
    
    @patch('modules.vulnerability_scanner.requests.get')
    def test_check_shellshock(self, mock_get):
        """
        اختبار فحص ثغرة Shellshock
        """
        # إعداد الاستجابة الوهمية
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.text = 'test'
        mock_get.return_value = mock_response
        
        # تنفيذ فحص ثغرة Shellshock
        result = self.vuln_scanner._check_shellshock()
        
        # التحقق من النتائج
        self.assertIsNotNone(result)
        self.assertFalse(result['vulnerable'])  # افتراضيًا غير قابل للاستغلال في الاختبار
        
        # التحقق من استدعاء الدالة الوهمية
        mock_get.assert_called_once()
    
    @patch('modules.vulnerability_scanner.requests.get')
    def test_check_ssl_tls(self, mock_get):
        """
        اختبار فحص إعدادات SSL/TLS
        """
        # إعداد الاستجابة الوهمية
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.headers = {
            'Server': 'nginx/1.18.0',
            'Strict-Transport-Security': 'max-age=31536000'
        }
        mock_get.return_value = mock_response
        
        # تنفيذ فحص إعدادات SSL/TLS
        result = self.vuln_scanner._check_ssl_tls()
        
        # التحقق من النتائج
        self.assertIsNotNone(result)
        self.assertIn('hsts', result)
        self.assertTrue(result['hsts']['enabled'])
        
        # التحقق من استدعاء الدالة الوهمية
        mock_get.assert_called_once()
    
    @patch('modules.vulnerability_scanner.VulnerabilityScanner._check_heartbleed')
    @patch('modules.vulnerability_scanner.VulnerabilityScanner._check_shellshock')
    @patch('modules.vulnerability_scanner.VulnerabilityScanner._check_ssl_tls')
    @patch('modules.vulnerability_scanner.VulnerabilityScanner._check_exposed_services')
    @patch('modules.vulnerability_scanner.VulnerabilityScanner._check_misconfigurations')
    def test_scan(self, mock_misconfig, mock_exposed, mock_ssl, mock_shellshock, mock_heartbleed):
        """
        اختبار وظيفة المسح الرئيسية
        """
        # إعداد النتائج الوهمية للفحوصات الفرعية
        mock_heartbleed.return_value = {'vulnerable': False, 'details': 'Not vulnerable to Heartbleed'}
        mock_shellshock.return_value = {'vulnerable': False, 'details': 'Not vulnerable to Shellshock'}
        mock_ssl.return_value = {'hsts': {'enabled': True, 'details': 'HSTS is properly configured'}}
        mock_exposed.return_value = []
        mock_misconfig.return_value = []
        
        # تنفيذ المسح
        result = self.vuln_scanner.scan()
        
        # التحقق من النتائج
        self.assertIsNotNone(result)
        self.assertIn('known_vulnerabilities', result)
        self.assertIn('ssl_tls', result)
        self.assertIn('exposed_services', result)
        self.assertIn('misconfigurations', result)
        
        # التحقق من استدعاء الدوال الوهمية
        mock_heartbleed.assert_called_once()
        mock_shellshock.assert_called_once()
        mock_ssl.assert_called_once()
        mock_exposed.assert_called_once()
        mock_misconfig.assert_called_once()
    
    @patch('modules.vulnerability_scanner.requests.get')
    def test_check_exposed_services(self, mock_get):
        """
        اختبار فحص الخدمات المكشوفة
        """
        # إعداد الاستجابات الوهمية
        mock_responses = []
        
        # إنشاء استجابة لكل خدمة (200 للموجودة، 404 لغير الموجودة)
        for i in range(len(self.vuln_scanner.exposed_services)):
            mock_response = MagicMock()
            # جعل بعض الخدمات موجودة وبعضها غير موجود للاختبار
            if i % 2 == 0:  # كل خدمة ثانية ستكون "موجودة"
                mock_response.status_code = 200
                mock_response.text = f"Service {i} is running"
            else:
                mock_response.status_code = 404
                mock_response.text = "Not Found"
            mock_responses.append(mock_response)
        
        # تكوين السلوك المتوقع للدالة الوهمية
        mock_get.side_effect = mock_responses
        
        # تنفيذ فحص الخدمات المكشوفة
        result = self.vuln_scanner._check_exposed_services()
        
        # التحقق من النتائج
        self.assertIsNotNone(result)
        self.assertIsInstance(result, list)
        
        # عدد الخدمات "الموجودة" يجب أن يكون نصف العدد الإجمالي
        expected_found_count = len(self.vuln_scanner.exposed_services) // 2 + (len(self.vuln_scanner.exposed_services) % 2)
        self.assertEqual(len(result), expected_found_count)
        
        # التحقق من عدد مرات استدعاء الدالة الوهمية
        self.assertEqual(mock_get.call_count, len(self.vuln_scanner.exposed_services))
    
    @patch('modules.vulnerability_scanner.requests.get')
    def test_check_misconfigurations(self, mock_get):
        """
        اختبار فحص الإعدادات الخاطئة
        """
        # إعداد الاستجابات الوهمية
        mock_responses = []
        
        # إنشاء استجابة لكل إعداد خاطئ محتمل (200 للموجود، 404 لغير الموجود)
        for i in range(len(self.vuln_scanner.misconfigurations)):
            mock_response = MagicMock()
            # جعل بعض الإعدادات الخاطئة موجودة وبعضها غير موجود للاختبار
            if i % 3 == 0:  # كل ثالث إعداد سيكون "موجودًا"
                mock_response.status_code = 200
                mock_response.text = f"Misconfiguration {i} found"
            else:
                mock_response.status_code = 404
                mock_response.text = "Not Found"
            mock_responses.append(mock_response)
        
        # تكوين السلوك المتوقع للدالة الوهمية
        mock_get.side_effect = mock_responses
        
        # تنفيذ فحص الإعدادات الخاطئة
        result = self.vuln_scanner._check_misconfigurations()
        
        # التحقق من النتائج
        self.assertIsNotNone(result)
        self.assertIsInstance(result, list)
        
        # عدد الإعدادات الخاطئة "الموجودة" يجب أن يكون ثلث العدد الإجمالي تقريبًا
        expected_found_count = len(self.vuln_scanner.misconfigurations) // 3 + (1 if len(self.vuln_scanner.misconfigurations) % 3 > 0 else 0)
        self.assertEqual(len(result), expected_found_count)
        
        # التحقق من عدد مرات استدعاء الدالة الوهمية
        self.assertEqual(mock_get.call_count, len(self.vuln_scanner.misconfigurations))

if __name__ == '__main__':
    unittest.main()